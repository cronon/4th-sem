## 1.3 Язык программирования Ruby
Создатель Ruby — японский разработчик Юкихиро Мацумото (Matz).
Ruby — динамический, рефлективный, интерпретируемый высокоуровневый язык программирования для быстрого и удобного объектно-ориентированного программирования. Язык обладает независимой от операционной системы реализацией многопоточности, строгой динамической типизацией, сборщиком мусора и многими другими возможностями. Ruby близок по особенностям синтаксиса к языкам Perl и Eiffel, по объектно-ориентированному подходу — к Smalltalk. Также некоторые черты языка взяты из Python, Lisp, Dylan и Клу.

Кроссплатформенная реализация интерпретатора языка является полностью свободной.
### Философия
Мацумото, фанат объектно-ориентированного программирования, мечтал о языке, более мощном, чем Perl, и более объектно-ориентированном, чем Python. Основное назначение Ruby — создание простых и в то же время понятных программ, где важна не скорость работы программы, а малое время разработки, понятность и простота синтаксиса.
Язык следует принципу «наименьшей неожиданности»: программа должна вести себя так, как ожидает программист. Однако в контексте Ruby это означает наименьшее удивление не при знакомстве с языком, а при его основательном изучении. Сам Мацумото утверждает, что целью разработки была минимизация неожиданностей при программировании для него, но после распространения языка он с удивлением узнал, что мышление программистов похоже, и для многих из них принцип «наименьшей неожиданности» совпал с его принципом.
Ruby также унаследовал идеологию языка программирования Perl в части предоставления программисту возможностей достижения одного и того же результата несколькими различными способами. Люди различны, и им для свободы необходима возможность выбирать. «Я предпочитаю обеспечить много путей, если это возможно, но поощрять или вести пользователей, чтобы выбрать лучший путь, если это возможно».
Одной из основных целей разработки было освобождение программистов от рутинной работы, которую вычислитель может выполнять быстрее и качественнее. Особое внимание, в частности, уделялось будничным рутинным занятиям (обработка текстов, администрирование), и для них язык настроен особенно хорошо.
В противовес машинно-ориентированным языкам, работающим быстрее, целью этой разработки был язык, наиболее близкий к человеку. Любая работа с компьютером выполняется людьми и для людей, и необходимо заботиться в первую очередь о затрачиваемых усилиях людей. Язык позволяет максимально быстро и просто для человека выполнить задачу, хотя, возможно, это и потребует дополнительного времени работы компьютера. На пороге технологической сингулярности, машинное время невероятно дешево. Так стоит ли тратить время человека на перекладывание байтов?
Принципы программирования и устройства языка иногда выделяются в термин «Путь Ruby» (англ. Ruby Way). Хэл Фултон выделяет такие принципы, как «просто, но не слишком просто», «принцип наименьшего удивления», вторичность скорости работы программы, динамичность, простые строгие правила, выполнение которых не доходит до педантизма, потребность создавать полезные и красивые программы как причина программирования. В целом они не имеют точной формулировки и иногда этот термин используется для критики.
### Возможности Ruby
Интерпретируемый язык:
* Возможность прямых системных вызовов.
* Мощная поддержка операций со строками и правилами (регулярными выражениями).
* Мгновенное проявление изменений во время разработки.
* Отсутствие стадии компиляции.

Простое и быстрое программирование:
* Не надо объявлять переменные.
* Переменные динамически типизированы.
* Простой и последовательный синтаксис.
* Автоматическое управление памятью.

Объектно-ориентированное программирование:
* Всё есть объект. Даже имя класса - это экземпляр класса Class.
* Классы, методы, наследование, полиморфизм, инкапсуляция и так далее.
* Методы-одиночки.
* Примеси (mixins) при помощи модулей (возможность расширить класс без наследования);
* Итераторы и замыкания.
* Широкие возможности метапрограммирования.

Удобства:
* Неограниченный диапазон значений целых чисел.
* Все операторы и управляющие структуры являются методами и возвращают значение.
* Динамическая загрузка.
* Механизм перехвата исключений.
* Поддержка потоков; как собственных, так и систем семейства UNIX.

Недостатки:
* Неуправляемость некоторых процессов (таких, как выделение памяти), невозможность задания низкоуровневых структур данных или подпрограмм;
* Невозможность компиляции и сопутствующей ей оптимизации программы;
* Открытость исходного кода даже в готовой программе (есть средство упаковки исходного кода в .exe-файл под Windows);
* Следствие двух первых недостатков — весьма низкая скорость запуска и выполнения программ.
* Не так уж и часто, но все же бывает, что документация только на японском.

### Примеры
Ruby — полностью объектно-ориентированный язык. В нём все данные являются объектами, в отличие от многих других языков, где существуют примитивные типы. Каждая функция — метод. Даже ключевые слова - всего лишь синтаксический сахар для методов.
В Ruby есть немало оригинальных решений, редко или вообще не встречающихся в распространённых языках программирования. Можно добавлять методы не только в любые классы, но и в любые объекты. Например, вы можете добавить к некоторой строке произвольный метод.
```ruby
                   # всё от символа # и до конца строки - комментарий
                   # = является оператором присваивания,
                   # символы в «"» - строка, которой можно манипулировать средствами языка
  str = "Привет"   # здесь создаётся переменная str, типа String
                   # def - ключевое слово для объявления функции
  def str.bye      # str. указывает, кому принадлежит метод (по умолчанию Object)
                   # bye - имя метода, за ним может следовать необязательный, заключённый в
                   # круглые скобки список параметров функции
    "Пока!"        # из метода возвращается последнее вычисленное значение (здесь - строка)
  end              # ключевым словом end заканчиваются практически все инструкции Ruby
                   # puts - метод,
                   # str.bye - обращение к методу bye объекта str
                   # значение, полученное из метода bye передаётся методу puts
                   # который выводит на экран информацию
  puts str.bye     #=> Пока!
```
Работа с массивами — одна из сильных сторон Ruby. Они автоматически изменяют размер, могут содержать любые элементы, а язык предоставляет мощные средства для их обработки.
```ruby
                          # создаём массив
 a = [1, 'hi', 3.14, 1, 2, [4, 5] * 3]
                           # => [1, "hi", 3.14, 1, 2, [4, 5, 4, 5, 4, 5]]
 
                           # обращение по индексу
 a[2]                      # => 3.14
 
                           # «разворачиваем» все внутренние массивы, удаляем одинаковые элементы
 a.flatten.uniq            # => [1, 'hi', 3.14, 2, 4, 5]
 
                           # пытаемся найти индекс элемента со значением 6
 a.index(6)                # => nil
                           # неудача: возвращается значение nil
 
                           # почти для всех функций предоставляется
                           # аналог с тем же названием, но заканчивающийся на «!»,
                           # который модифицирует контейнер
 a.flatten!                # => [1, "hi", 3.14, 1, 2, 4, 5, 4, 5, 4, 5]
 
                           # находим индекс первого элемента со значением 4
 a.index(4)                # => 5
```
Следующий пример определяет класс с именем Person, предназначенный для хранения информации об имени и возрасте некоторой персоны.
```ruby
class Person < Object       # объявление класса начинается с ключевого слова class, за которым
                             # следует имя, класс Person наследуется от Object
   include Comparable        # подмешиваются к классу методы экземпляра
                             # и добавляет методы <, <=, ==, >=, > и between?
                             # с использованием нижеопределённого
                             # в классе <=>

   @variable                 # переменная экземпляра
   @@count_obj = 0           # переменная класса для подсчёта числа созданных объектов

                             # конструктор для создания объектов с помощью new
   def initialize(name, age) # name, age - параметры метода
                             # название переменных объекта начинается с @
     @name, @age = name, age # создаём объекты и увеличиваем счётчик на 1
     @@count_obj += 1
   end
 
   def <=>(person)           # переопределение оператора <=> (spaceship) 
                             # (это даёт возможность использовать метод sort)
     @age <=> person.age     # из метода возвращается последнее вычисленное выражение,
   end
 
   def to_s                  # для форматированного вывода информации puts
     "#{@name} (#{@age})"    # конструкция #{x} в 2-х кавычках замещается в Ruby значением x
   end
 
   def inspect               # похож на to_s, но используется для диагностического вывода
     "<#{@@count_obj}:#{to_s}>"
   end
                             # пример метапрограммирования: добавляет геттеры для доступа к
                             # переменным объекта
   attr_reader :name, :age
 end
                             # создаём массив объектов
 group = [ Person.new("John", 20),
          Person.new("Markus", 63),
          Person.new("Ash", 16) ]
                      # => [<3:John (20)>, <3:Markus (63)>, <3:Ash (16)>]
                      # здесь при работе с irb автоматически вызывается метод inspect
                      # вызываем методы массива сортировка и разворачивание его в обратном порядке
 puts group.sort.reverse # Печатает:
                         # Markus (63)
                         # John (20)
                         # Ash (16)
                                    # обращаемся к функции, которая была добавлена
                                    # автоматически(используя <=>) при включении Comparable
 group[0].between?(group[2], group[1]) # => true
```
### Приминение
Ruby используется в NASA, NOAA (национальная администрация по океану и атмосфере), Motorola и других крупных организациях. Следующие программы используют Ruby как скриптовый язык для расширения возможностей программы или написаны на нём (частично или полностью).
* RPG Maker (RPG Maker XP) — RGSS (Ruby Game Scripting System)
* Amarok
* SketchUp
* Inkscape — скрипты для обработки векторных изображений
* Metasploit
* Chef, Puppet — системы управления конфигурациями
* Redmine — багтрекер
* XChat
* WATIR (англ. Web Application Testing in Ruby) — свободное средство для автоматического тестирования веб-приложений в браузере.
* Puppet